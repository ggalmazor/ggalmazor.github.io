<!DOCTYPE html>
<html lang="en">
<title>Refactoring is spelled T E S T</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="https://unpkg.com/tachyons/css/tachyons.min.css">
<body class="w-100 avenir black-70 bg-white pa3 f3">
<nav class="center w-100 mw7 mb5-ns flex flex-column flex-row-ns justify-between items-end">
    <a href="/" class="dib ttu link dim black-70 fw6 pt3-ns pr3-ns pb3-ns">⬅&nbsp;back</a>
    <span class="dib dn dib-ns w-100"></span>
    <a href="/about.html" class="dib ttu link dim black-70 pt3-ns pb3-ns pl3-ns">about</a>
</nav>
<section class="w-100 mw7 center">
    <h2 class="f3 mb4">Refactoring is spelled T E S T</h2>

    <p class="f4 lh-copy"><img alt="Refactoring is spelled T E S T" src="../assets/image.webp"/></p>

    <p class="f4 lh-copy">Refactoring is an essential practice in software development, yet I often find that the role
        of testing doesn’t receive the attention it deserves. While Martin Fowler and Kent Beck stress the importance of
        small, behavior-preserving transformations for safe refactoring, the true safety net lies in thorough testing.
        Without it, even the most well-intentioned refactor can introduce risks that undermine the stability of a
        system.</p>

    <p class="f4 lh-copy">Martin Fowler and Kent Beck are leading experts in software development with deep experience
        in practices like agile, XP, and test-driven development. Their approach to making small, incremental
        improvements without changing the behavior has become a foundational principle for maintaining and evolving
        codebases efficiently and safely.</p>

    <blockquote class="mb0 pb0 ml0 mt0 pl4 black-70 bl bw2 b--black-70">
        <p class="f4 mb0 pb0 lh-copy mt0 i">Refactoring is a controlled technique for improving the design of an
            existing code base. Its essence is applying a series of small <strong>behavior-preserving
                transformations</strong>, each of which "too small to be worth doing". However the cumulative effect of
            each of these transformations is quite significant. By doing them in small steps you reduce the risk of
            introducing errors. You also avoid having the system broken while you are carrying out the restructuring -
            which allows you to gradually refactor a system over an extended period of time.</p>
    </blockquote>

    <p class="f5 mt0 pt1 pl4 lh-copy">(emphasis is mine, read more at <a
            href="https://martinfowler.com/books/refactoring.html" class="link dim black-90 fw5">martinfowler.com/books/refactoring.html</a>)
    </p>

    <p class="f4 lh-copy">Based on that and my own experience working with legacy codebases, this is my take on
        refactoring:</p>

    <ul class="f4">
        <li>Refactoring is about changing the code's design without changing its behavior.</li>
        <li>Addressing refactors in small steps is paramount to support an iterative & incremental roll-out strategy.
        </li>
        <li>Working on small refactors enables teams to have liquidity and work on what's most important at each time.
        </li>
    </ul>

    <p class="f4 lh-copy">However, the most challenging aspect of the refactoring process is that <span class="b">it
        must not change the system's behavior</span> (i.e. break it).</p>

    <p class="f4 lh-copy">Assuming that we know what the system's behavior should be, we can change the code and then
        test the system manually but humans are error-prone, and our biases and external factors make of us poor judges
        of our own work. On top of that, manual testing doesn't work at scale. The bottom line is that, as a software
        developer, I don't want stakeholders to take my word on not breaking anything. I want a safety net that
        guarantees it, and can be audited by my fellow team mates.</p>

    <p class="f4 lh-copy">We can agree that automated testing is the way to go. Tests play a paramount role in
        refactorings because they're the tool to guarantee we're not introducing any change in the system's behavior
        after we're done.</p>

    <p class="f4 lh-copy">As Fowler and Beck highlight the importance of small, incremental changes, it's crucial to
        remember that true refactoring can only happen within the safety of a robust test harness. Without tests in
        place, any code changes risk introducing errors, undermining the very purpose of refactoring.</p>

    <p class="f4 lh-copy">In my experience, however, tests are often more about implementation details than the system's
        behavior, which puts us in a tough spot when addressing complicated or risky refactorings. We need to understand
        the system's behavior and then write tests that effectively describe and verify this behavior.</p>

    <h3 class="f3 mb4">System's behavior</h3>

    <p class="f4 lh-copy">A system's behavior comprises its observable actions (side-effects) and responses (outputs) in
        reaction to stimuli. Let's drill down into the keywords in this definition:
    </p>

    <p class="f4 lh-copy"><span class="b">Outputs</span> should be straightforward to understand: when I drive the
        system, anything I get in response <span class="i">is</span> the output.</p>

    <p class="f4 lh-copy"><span class="b">Side-effects</span> can be tricky, though. In a nutshell, they include
        mutating the global state, I/O operations, and altering the execution flow (exceptions!).</p>

    <p class="f4 lh-copy">Sometimes, outputs can be difficult to tell apart from side effects. For example, in a Ruby on
        Rails codebase, we could assume that a controller's output would be the actual HTTP response. However, the
        response object is part of Rack's state, and Rails mutates it based on the controller's execution. In this
        context, the controller performs a side effect of mutating an object in the global state, and has no output.</p>

    <p class="f4 lh-copy"><span class="b">Stimuli</span> would include actions performed by our users, like clicking
        buttons or sending API requests, receiving webhooks from third-party services, a scheduler running programmed
        tasks, etc. These are the triggers that initiate some action in our system.</p>

    <p class="f4 lh-copy">We have established that automated testing is the way to go, and now we have a basic
        understanding of what to look for when discussing "behavior". Let's move on to the tests.</p>

    <h3 class="f3 mb4">Testing the behavior</h3>

    <p class="f4 lh-copy">Refactoring without a test in place is not refactoring - it's just code modification. To truly
        refactor, we must first establish a test harness that verifies the existing behavior. This ensures that any
        changes we make preserve the functionality of the system.</p>

    <p class="f4 lh-copy">Luckily, the stimuli, outputs, and side effects fall directly into common test concerns. In a
        classic AAA (arrange, action, assert) test structure, stimuli determine the test's action that will drive our
        SUT, and outputs and side effects are what we need to assert.</p>

    <p class="f4 lh-copy">This approach applies to any abstraction level we want. It can be as small as a single
        function or as big as the whole system. The challenging part is determining what our SUT should be and,
        therefore, determining what layer needs to drive our system in our tests.</p>

    <p class="f4 lh-copy">Code that lives at lower levels of abstraction is concrete. The combinatorial complexity of
        how it can be driven and the possible range of outputs and side effects should be small, translating to smaller
        tests with simpler setups.</p>

    <p class="f4 lh-copy">The combinatorial complexity grows exponentially as we increase the abstraction level, and
        writing tests becomes more challenging.</p>

    <p class="f4 lh-copy">Regardless of the layer our SUT lives at, one key aspect of our tests is that it must not leak
        or depend upon the SUT's implementation details. We need those tests in green during the whole refactoring
        exercise.</p>


    <p class="f4 lh-copy">Now that we understand the system's behavior and can automatically verify it using our tests,
        the fun part begins.</p>

    <h3 class="f3 mb4">Refactoring (conclusions)</h3>

    <p class="f4 lh-copy">Refactoring is safe when we have automated tests that guarantee we won't change the system's
        behavior. By definition, we can't break anything as long as those tests are green, and we can safely explore any
        idea, take any path.</p>

    <p class="f4 lh-copy">Refactoring is one of software development's most creative, fun, and satisfying parts. It's
        also one of the most important activities we must perform because it's literally about paying technical debt. It
        makes the system more viable and future-proof, ready to absorb change cost-effectively.</p>
</section>
<footer class="mt5 w-100 mw7 center">
    <p class="f6">
        <span class="dib mr2">©2021 ggalmazor.com</span>
        <span class="dib mr2">/</span>
        <span class="dib">inspired by <a href="https://javisantana.com" class="link dim dark-blue fw5">javisantana.com</a></span>
    </p>
</footer>
</body>
</html>
